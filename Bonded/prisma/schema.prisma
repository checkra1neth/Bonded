generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PortfolioVisibilityLevel {
  HIDDEN
  SUMMARY
  DETAILED
}

enum ActivityVisibilityLevel {
  HIDDEN
  TIMEZONE_ONLY
  PATTERNS
}

enum CompatibilityCategory {
  CRYPTO_SOULMATES
  DEFI_COMPATIBLE
  POTENTIAL_MATCH
  DIFFERENT_STRATEGIES
}

enum ConversationRole {
  SEEKER
  CANDIDATE
  SYSTEM
}

enum MessageDeliveryStatus {
  SENT
  DELIVERED
  READ
}

model User {
  id            String   @id @default(cuid())
  walletAddress String   @unique
  fid           Int?
  ensName       String?
  basename      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  portfolio             Portfolio?
  compatibilityAnalyses CompatibilityAnalysis[] @relation("AnalysisOwner")
  compatibilityResults  CompatibilityAnalysis[] @relation("AnalysisTarget")
  conversations         ConversationParticipant[]
}

model Portfolio {
  id         String   @id @default(cuid())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String   @unique
  snapshot   Json
  highlights String[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  privacy  PortfolioPrivacy?
  analyses CompatibilityAnalysis[] @relation("AnalysisPortfolio")
}

model PortfolioPrivacy {
  id                 String                   @id @default(cuid())
  portfolio          Portfolio                @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  portfolioId        String                   @unique
  shareTokens        Boolean                  @default(true)
  shareDefi          Boolean                  @default(true)
  shareNfts          Boolean                  @default(true)
  shareActivity      Boolean                  @default(true)
  shareHighlights    Boolean                  @default(true)
  tokenVisibility    PortfolioVisibilityLevel @default(SUMMARY)
  defiVisibility     PortfolioVisibilityLevel @default(SUMMARY)
  nftVisibility      PortfolioVisibilityLevel @default(SUMMARY)
  activityVisibility ActivityVisibilityLevel  @default(PATTERNS)
  viewerFids         Int[]
  viewerAddresses    String[]
  createdAt          DateTime                 @default(now())
  updatedAt          DateTime                 @updatedAt
}

model CompatibilityAnalysis {
  id              String                @id @default(cuid())
  owner           User                  @relation("AnalysisOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId         String
  target          User?                 @relation("AnalysisTarget", fields: [targetUserId], references: [id], onDelete: SetNull)
  targetUserId    String?
  portfolio       Portfolio             @relation("AnalysisPortfolio", fields: [portfolioId], references: [id], onDelete: Cascade)
  portfolioId     String
  snapshot        Json
  sharedInterests Json
  reasoning       Json
  overallScore    Float
  tokenScore      Float
  defiScore       Float
  nftScore        Float
  activityScore   Float
  category        CompatibilityCategory
  highlights      String[]
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  @@index([ownerId], map: "CompatibilityAnalysis_ownerId_idx")
  @@index([targetUserId], map: "CompatibilityAnalysis_targetUserId_idx")
  @@index([portfolioId], map: "CompatibilityAnalysis_portfolioId_idx")
}

model Conversation {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  lastMessageAt  DateTime?

  participants ConversationParticipant[]
  messages     Message[]
}

model ConversationParticipant {
  id             String           @id @default(cuid())
  conversation   Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  role           ConversationRole @default(SEEKER)
  joinedAt       DateTime         @default(now())
  lastReadAt     DateTime?
  isTyping       Boolean          @default(false)

  messages Message[]

  @@unique([conversationId, userId])
  @@index([conversationId], map: "ConversationParticipant_conversationId_idx")
  @@index([userId], map: "ConversationParticipant_userId_idx")
}

model Message {
  id             String                @id @default(cuid())
  conversation   Conversation          @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  sender         ConversationParticipant @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId       String
  body           String
  status         MessageDeliveryStatus @default(SENT)
  deliveredAt    DateTime?
  readAt         DateTime?
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt

  @@index([conversationId], map: "Message_conversationId_idx")
  @@index([senderId], map: "Message_senderId_idx")
}
